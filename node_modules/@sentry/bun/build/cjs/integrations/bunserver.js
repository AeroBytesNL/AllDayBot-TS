Object.defineProperty(exports, '__esModule', { value: true });

const core = require('@sentry/core');

const INTEGRATION_NAME = 'BunServer';

const _bunServerIntegration = (() => {
  return {
    name: INTEGRATION_NAME,
    setupOnce() {
      instrumentBunServe();
    },
  };
}) ;

/**
 * Instruments `Bun.serve` to automatically create transactions and capture errors.
 *
 * Enabled by default in the Bun SDK.
 *
 * ```js
 * Sentry.init({
 *   integrations: [
 *     Sentry.bunServerIntegration(),
 *   ],
 * })
 * ```
 */
const bunServerIntegration = core.defineIntegration(_bunServerIntegration);

/**
 * Instruments Bun.serve by patching it's options.
 */
function instrumentBunServe() {
  Bun.serve = new Proxy(Bun.serve, {
    apply(serveTarget, serveThisArg, serveArgs) {
      instrumentBunServeOptions(serveArgs[0]);
      const server = serveTarget.apply(serveThisArg, serveArgs);

      // A Bun server can be reloaded, re-wrap any fetch function passed to it
      // We can't use a Proxy for this as Bun does `instanceof` checks internally that fail if we
      // wrap the Server instance.
      const originalReload = server.reload.bind(server);
      server.reload = (serveOptions) => {
        instrumentBunServeOptions(serveOptions);
        return originalReload(serveOptions);
      };

      return server;
    },
  });
}

/**
 * Instruments Bun.serve `fetch` option to automatically create spans and capture errors.
 */
function instrumentBunServeOptions(serveOptions) {
  serveOptions.fetch = new Proxy(serveOptions.fetch, {
    apply(fetchTarget, fetchThisArg, fetchArgs) {
      return core.withIsolationScope(isolationScope => {
        const request = fetchArgs[0];
        const upperCaseMethod = request.method.toUpperCase();
        if (upperCaseMethod === 'OPTIONS' || upperCaseMethod === 'HEAD') {
          return fetchTarget.apply(fetchThisArg, fetchArgs);
        }

        const parsedUrl = core.parseUrl(request.url);
        const attributes = {
          [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.bun.serve',
          [core.SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD]: request.method || 'GET',
          [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
        };
        if (parsedUrl.search) {
          attributes['http.query'] = parsedUrl.search;
        }

        const url = core.getSanitizedUrlString(parsedUrl);

        isolationScope.setSDKProcessingMetadata({
          normalizedRequest: {
            url,
            method: request.method,
            headers: request.headers.toJSON(),
            query_string: core.extractQueryParamsFromUrl(url),
          } ,
        });

        return core.continueTrace(
          { sentryTrace: request.headers.get('sentry-trace') || '', baggage: request.headers.get('baggage') },
          () => {
            return core.startSpan(
              {
                attributes,
                op: 'http.server',
                name: `${request.method} ${parsedUrl.path || '/'}`,
              },
              async span => {
                try {
                  const response = await (fetchTarget.apply(fetchThisArg, fetchArgs)

);
                  if (response && response.status) {
                    core.setHttpStatus(span, response.status);
                    isolationScope.setContext('response', {
                      headers: response.headers.toJSON(),
                      status_code: response.status,
                    });
                  }
                  return response;
                } catch (e) {
                  core.captureException(e, {
                    mechanism: {
                      type: 'bun',
                      handled: false,
                      data: {
                        function: 'serve',
                      },
                    },
                  });
                  throw e;
                }
              },
            );
          },
        );
      });
    },
  });
}

exports.bunServerIntegration = bunServerIntegration;
exports.instrumentBunServe = instrumentBunServe;
//# sourceMappingURL=bunserver.js.map
